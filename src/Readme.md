# 一些说明
## chapter2
    线性表 其中包含顺序表和链表
    - 顺序表适用于查询较多的场景，链表适用了增删较多的场景；
      顺序表使用了更少了存储空间，链表由于需要开辟next域需要花费更多的存储空间
## chapter3
    栈和队列，其中主要是通过chapter2章节的内容来进行实现，有些实现缺少相关的Exception
    （链式栈不能进行非空判断isEmpty() ）
    在实现栈的时候，可以给一个int top变量作为栈顶指针域
    - 初始的时候，顺序栈必须说明一个固定的长度，当栈不满则造成浪费；
      链式栈长度可变，不需要预先设定，相对来说节省空间，但是每个结点中的指针域会产生结构开销
    - 当需要多个栈共享的时候，可以充分利用顺序栈的单向延伸性（一个栈增长，一个栈缩短）

    队列也分为线性队列和链式队列，当队列在顺序存储的时候，经常出现“假溢出”现象，解决假溢出通常采用循环队列方法
    - 假溢出：指在入队和出队操作中，头尾指针只增加或者只减小，使得被删元素的空间无法重新利用
    - 将顺序队列设计成在逻辑上首尾相接的循环结构，即可使用循环使用顺序队列的连续存储单元
        - 入队时 rear = (rear + 1) % maxsize 出队时 front = (front + 1) % maxsize
        - 在入队时先不修改rear的值，而是先判断(rear + 1) % maxsize == front，如果成立则表示队列已满（实际上此时还有front指向的位置空闲）
        - 出队的时候只要判断rear == front，如果成立表示队列已空，否则只要front = (front + 1) % maxsize直接删除元素即可
        - 这种方法存储的数据元素个数是maxsize - 1
            - 本质上来说，队首指针指向即将入队的位置，队尾指针指向即将出队的位置